import java.util.regex.Pattern

buildscript {
  repositories {
    maven { url 'https://logl.bintray.com/logl/' }
    jcenter()
  }
}
plugins {
  id 'com.diffplug.gradle.spotless' version '3.15.0'
  id 'net.ltgt.errorprone' version '0.6'
  id 'io.spring.dependency-management' version '1.0.6.RELEASE'
  id 'com.github.hierynomus.license' version '0.14.0'
  id 'com.jfrog.bintray' version '1.8.1'
  id 'org.jetbrains.kotlin.jvm' version '1.3.0-rc-198'
  id 'org.jetbrains.dokka' version '0.9.17'
  id "com.dorongold.task-tree" version "1.3.1"
}

description = 'A simple Java logging framework for libraries'


//////
// Version numbering

def versionNumber = '0.4.0'
def buildVersion = versionNumber + buildTag()

static String buildTag() {
  if (System.getenv('BUILD_RELEASE') == 'true') {
    return ''
  }
  if (System.getenv('CIRCLECI')) {
    def buildNumber = System.getenv('CIRCLE_SHA1').take(4).toUpperCase() +
      String.format('%02X', System.getenv('CIRCLE_BUILD_NUM').toInteger() % 256, 16)
    return '-' + buildNumber + '-snapshot'
  }
  return '-dev'
}


//////
// Default tasks and build aliases

defaultTasks 'build', 'checkLicenses', 'javadoc'

def buildAliases = ['dev': [
    'spotlessApply',
    'build',
    'checkLicenses',
    'javadoc'
  ]]

def expandedTaskList = []
gradle.startParameter.taskNames.each {
  expandedTaskList << (buildAliases[it] ? buildAliases[it] : it)
}
gradle.startParameter.taskNames = expandedTaskList.flatten()


//////
// Gradle script formatting

spotless {
  groovyGradle {
    target '**/*.gradle'
    greclipse().configFile(rootProject.file('gradle/greclipse-gradle-consensys-style.properties'))
    endWithNewline()
  }
}


allprojects {
  apply plugin: 'java-library'
  apply plugin: 'kotlin'
  apply plugin: 'org.jetbrains.dokka'
  apply plugin: 'io.spring.dependency-management'
  apply plugin: 'jacoco'
  apply from: "${rootDir}/dependency-versions.gradle"
  apply from: "${rootDir}/gradle/check-licenses.gradle"

  version = buildVersion

  repositories { jcenter() }


  //////
  // Artifact locations

  jar {
    destinationDir = file("${rootProject.buildDir}/libs")
  }

  task sourcesJar(type: Jar, dependsOn: classes) {
    destinationDir = file("${rootProject.buildDir}/src")
    classifier = 'sources'
    from sourceSets.main.allSource
  }

  task javadocJar(type: Jar, dependsOn: javadoc) {
    destinationDir = file("${rootProject.buildDir}/docs")
    classifier = 'javadoc'
    from javadoc.destinationDir
  }

  task dokkaJar(type: Jar, dependsOn: dokka) {
    destinationDir = file("${rootProject.buildDir}/docs")
    classifier = 'dokka'
    from dokka.outputDirectory
  }


  //////
  // Documentation

  dokka {
    outputFormat = 'html'
    outputDirectory = "$buildDir/docs/dokka"
    jdkVersion = 8
    includeNonPublic = false
    def relativePath = rootDir.toPath().relativize(projectDir.toPath()).toString()
    linkMapping {
      dir = projectDir.toString()
      url = "https://github.com/logl/logl/blob/master/$relativePath"
      suffix = "#L"
    }
  }
}


//////
// Top-level target for deploy (bintrayUpload depends on it)

task deploy() {}


subprojects {
  apply plugin: 'net.ltgt.errorprone'
  apply plugin: 'com.jfrog.bintray'
  apply plugin: 'maven-publish'
  apply plugin: 'signing'

  //////
  // Source formatting

  apply plugin: 'com.diffplug.gradle.spotless'
  spotless {
    java {
      target project.fileTree(project.projectDir) {
        include '**/*.java'
        exclude '**/generated-src/**/*.*'
      }
      removeUnusedImports()
      licenseHeaderFile rootProject.file('gradle/spotless.license.java')
      eclipse().configFile(rootProject.file('gradle/eclipse-java-consensys-style.xml'))
      importOrder 'org.logl', 'java', ''
      endWithNewline()
    }
    kotlin {
      licenseHeaderFile rootProject.file('gradle/spotless.license.java')
      ktlint().userData(['indent_size': '2', 'continuation_indent_size' : '2', 'max_line_length': '120'])
      endWithNewline()
    }
  }


  //////
  // Compiler arguments

  sourceCompatibility = '1.8'
  targetCompatibility = '1.8'

  jacoco { toolVersion = '0.8.2' }

  dependencies {
    errorprone("com.google.errorprone:error_prone_core")
    if (JavaVersion.current().isJava8()) {
      errorproneJavac("com.google.errorprone:javac")
    }
  }

  tasks.withType(JavaCompile) {
    options.compilerArgs += [
      '-Xlint:unchecked',
      '-Xlint:cast',
      '-Xlint:rawtypes',
      '-Xlint:overloads',
      '-Xlint:divzero',
      '-Xlint:finally',
      '-Xlint:static',
      '-Werror'
    ]
  }

  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
      jvmTarget = "1.8"
      allWarningsAsErrors = true
      freeCompilerArgs = [
        '-Xjsr305=strict'
      ]
    }
  }


  //////
  // Parallel build execution

  tasks.withType(Test) {
    // If GRADLE_MAX_TEST_FORKS is not set, use half the available processors
    maxParallelForks = (System.getenv('GRADLE_MAX_TEST_FORKS') ?:
      (Runtime.runtime.availableProcessors().intdiv(2) ?: 1)).toInteger()
  }

  tasks.withType(JavaCompile) {
    options.fork = true
    options.incremental = true
  }

  task allDependencies(type: DependencyReportTask) {}


  //////
  // Use JUnit5 for testing

  test { useJUnitPlatform() }


  //////
  // Packaging and deployment

  tasks.withType(Jar) {
    baseName = rootProject.name + '-' + project.name
    manifest {
      attributes('Implementation-Title': baseName,
      'Implementation-Version': project.version)
    }
  }

  artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
  }

  signing {
    useGpgCmd()
    sign configurations.archives
  }

  publishing {
    publications {
      MavenDeployment(MavenPublication) {
        from components.java
        artifact sourcesJar { classifier 'sources' }
        artifact javadocJar { classifier 'javadoc' }
        groupId 'org.logl'
        artifactId project.jar.baseName
        version project.version
        pom {
          name = project.jar.baseName
          description = project.description
          url = 'https://github.com/logl/logl'
          licenses {
            license {
              name = "MIT License"
              url = "http://www.opensource.org/licenses/mit-license.php"
            }
          }
          scm {
            connection = 'scm:https://github.com/logl/logl.git'
            developerConnection = 'scm:git@github.com:logl/logl.git'
            url = 'https://github.com/logl/logl'
          }
          developers {
            developer {
              name = 'Chris Leishman'
              email = 'chris@leishman.org'
            }
            developer {
              name = 'Antoine Toulme'
              email = 'antoine@lunar-ocean.com'
            }
          }
        }
        pom.withXml {
          // use inline versions rather than pom dependency management
          asNode().remove(asNode().dependencyManagement[0])

          def dependenciesNode = asNode().appendNode('dependencies')
          def addDependencyNode = { dep, optional ->
            def dependencyNode = dependenciesNode.appendNode('dependency')
            if (dep instanceof ProjectDependency) {
              dependencyNode.appendNode('groupId', 'io.logl')
              dependencyNode.appendNode('artifactId', rootProject.name + '-' + dep.name)
              dependencyNode.appendNode('version', dep.version)
            } else {
              dependencyNode.appendNode('groupId', dep.group)
              dependencyNode.appendNode('artifactId', dep.name)
              if (dep.version != null) {
                dependencyNode.appendNode('version', dep.version)
              } else {
                def version = dependencyManagement.managedVersions["$dep.group:$dep.name"]
                dependencyNode.appendNode('version', version)
              }
            }
            if (optional) {
              dependencyNode.appendNode('optional', 'true')
            }

            def ers = dep.excludeRules
            if (!ers.empty) {
              def exclusionsNode = dependencyNode.appendNode('exclusions')
              ers.each { er ->
                def exclusionNode = exclusionsNode.appendNode('exclusion')
                exclusionNode.appendNode('groupId', er.group)
                exclusionNode.appendNode('artifactId', er.module)
              }
            }
          }

          configurations.compile.allDependencies.each { dep ->
            addDependencyNode(dep, false)
          }
          configurations.compileOnly.allDependencies.each { dep ->
            addDependencyNode(dep, true)
          }

          if (System.getenv('ENABLE_SIGNING') == 'true') {
            def pomFile = file("${project.buildDir}/generated-pom.xml")
            writeTo(pomFile)
            def pomAscFile = signing.sign(pomFile).signatureFiles[0]
            artifact(pomAscFile) {
              classifier = null
              extension = 'pom.asc'
            }
          }
        }

        if (System.getenv('ENABLE_SIGNING') == 'true') {
          // create the signed artifacts
          tasks.signArchives.signatureFiles.each {
            artifact(it) {
              def matcher = it.file =~ /-(sources|javadoc)\.jar\.asc$/
              if (matcher.find()) {
                classifier = matcher.group(1)
              } else {
                classifier = null
              }
              extension = 'jar.asc'
            }
          }
        }
      }
    }
  }

  tasks.withType(Sign) {
    onlyIf { System.getenv('ENABLE_SIGNING') == 'true' }
  }

  model {
    tasks.generatePomFileForMavenDeploymentPublication {
      destination = file("$buildDir/generated-pom.xml")
    }
    tasks.publishMavenDeploymentPublicationToMavenLocal { dependsOn project.tasks.signArchives }
  }

  def artifactIdMatcher = Pattern.compile("(.*)-\\d.*")
  bintray {
    user = System.getenv('BINTRAY_USER')
    key = System.getenv('BINTRAY_KEY')
    publications = ['MavenDeployment']
    filesSpec {
      project.extensions.getByType(PublishingExtension).publications.all { publication ->
        publication.getArtifacts().all {
          def ascFile = new File(it.file.getParentFile(), it.file.getName() + '.asc')
          if (ascFile.exists()) {
            def matcher = artifactIdMatcher.matcher(it.file.getName())
            matcher.find()
            def artifactId = matcher.group(1)
            from ascFile.getAbsolutePath()
            into publication.groupId.replaceAll('\\.', '/') + '/' + artifactId + '/' + publication.version + '/'
          }
        }
      }
    }
    dryRun = !(System.getenv('BINTRAY_DEPLOY') == 'true')
    publish = true
    pkg {
      userOrg = 'logl'
      repo = 'logl'
      name = 'logl'
      websiteUrl = 'https://github.com/logl/logl'
      vcsUrl = 'https://github.com/logl/logl'
      licenses = ['Apache-2.0']
      version {
        name = project.version
        desc = 'logl distribution'
        released = new Date()
        vcsTag = project.version
      }
    }
  }
  deploy.dependsOn bintrayUpload
}


//////
// Task to generate coverage report

task jacocoRootTestReport(type: JacocoReport) {
  dependsOn = subprojects.test
  additionalSourceDirs = files(subprojects.sourceSets.main.allSource.srcDirs)
  sourceDirectories = files(subprojects.sourceSets.main.allSource.srcDirs)
  classDirectories =  files(subprojects.sourceSets.main.output)
  executionData = files(subprojects.jacocoTestReport.executionData)
  reports {
    html.enabled = true
    xml.enabled = true
    csv.enabled = false
  }
  doFirst {
    executionData = files(executionData.findAll { it.exists() })
  }
}


//////
// Bundle all subproject javadoc into a single set

javadoc {
  options.overview("${rootProject.projectDir}/site/overview.html")
  subprojects.each {
    dependsOn it.javadoc
    source += it.javadoc.source
    classpath += it.javadoc.classpath
  }
}

dokka {
  moduleName = rootProject.name
  subprojects.each {
    dependsOn it.classes
    it.sourceSets.main.output.each { d ->
      if (d.exists()) {
        classpath += d
      }
    }
  }
  sourceDirs = files(subprojects.collect {
    return [
      new File(it.projectDir, '/src/main/kotlin'),
      new File(it.projectDir, '/src/main/java')
    ]
  })
  linkMapping {
    dir = rootDir.toString()
    url = "https://github.com/logl/logl/blob/master"
    suffix = "#L"
  }

  includes = ['PACKAGES.md']

  externalDocumentationLink {
    url = new URL("https://docs.oracle.com/javase/8/docs/api/")
  }

  externalDocumentationLink {
    url = new URL('https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/')
  }
}

dokkaJar {
  baseName = rootProject.name
  manifest {
    attributes('Implementation-Title': baseName,
    'Implementation-Version': project.version)
  }
}


//////
// Don't build a top-level jar

jar { enabled = false }
